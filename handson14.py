# -*- coding: utf-8 -*-
"""Handson14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JoZCQjQW-V4ADXvomgv9o8HTgZneFU1J
"""

# Dijkstra's Algorithm
import heapq

def dijkstra(graph, source):
    V = len(graph)
    dist = [float('inf')] * V
    dist[source] = 0
    pq = [(0, source)]  # (distance, vertex)

    while pq:
        cur_dist, u = heapq.heappop(pq)
        if cur_dist > dist[u]:
            continue

        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(pq, (dist[v], v))

    print(f"Shortest distances from source {source}:")
    for i in range(V):
        print(f"Vertex {i}: {dist[i]}")

# Example
graph = [
    [(1, 4), (2, 1)],
    [(3, 1)],
    [(1, 2), (3, 5)],
    []
]
dijkstra(graph, 0)

#Bellman-Ford Algorithm
def bellman_ford(graph, V, source):
    dist = [float('inf')] * V
    dist[source] = 0

    for _ in range(V - 1):
        for u in range(V):
            for v, weight in graph[u]:
                if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                    dist[v] = dist[u] + weight

    # Check for negative-weight cycles
    for u in range(V):
        for v, weight in graph[u]:
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                print("Negative weight cycle detected!")
                return

    print(f"Shortest distances from source {source}:")
    for i in range(V):
        print(f"Vertex {i}: {dist[i]}")

# Example
graph = [
    [(1, 1), (2, 4)],
    [(2, -3), (3, 2)],
    [(3, 3)],
    []
]
V = 4
bellman_ford(graph, V, 0)

# Floyd-Warshall Algorithm
def floyd_warshall(graph):
    V = len(graph)
    dist = [[float('inf')] * V for _ in range(V)]

    for u in range(V):
        for v, weight in graph[u]:
            dist[u][v] = weight
        dist[u][u] = 0

    for k in range(V):
        for i in range(V):
            for j in range(V):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    print("Shortest distances between all pairs:")
    for i in range(V):
        for j in range(V):
            print(f"{dist[i][j]:<7}", end=" ")
        print()

# Example
graph = [
    [(1, 3), (3, 5)],
    [(0, 2), (3, 4)],
    [(1, 1)],
    [(2, 2)]
]
floyd_warshall(graph)